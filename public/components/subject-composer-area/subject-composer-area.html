<!--
  This compoenent handles de creation and edition of the hole Subject content.
  The subject composer area is responsible for the creation and edition of:
    - Hypervideos and their subvideo components.
    - Connections between hypervideos created.

  These needed components were created in order to uncouple the view. They
  are listed below in costom implemented components.
-->

<!-- Polymer components used -->
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../bower_components/neon-animation/neon-animations.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<!-- Custom implemented components -->
<link rel="import" href="../../components/hypervideo-node/hypervideo-node.html">
<link rel="import" href="../../components/connection-node/connection-node.html">
<link rel="import" href="../../components/grid-container/grid-container.html">

<dom-module id="subject-composer-area">
  <style is="custom-style">
    #backcanvas {
      position: absolute;
      top: 75px;
      bottom: 10px;
      left: 10px;
      right: 10px;
      padding-top: 25px;
      background-color:rgba(246,246,246,1);/*var(--light-divider-color);*/
    }
    #backcanvas canvas{
      width: 100%;
      height: 100%;
    }
    #toucharea {
      position: absolute;
      top: 100px;
      bottom: 35px;
      left: 35px;
      right: 35px;
      background-color:rgba(220,220,220,0.0);/*var(--light-divider-color);*/
      overflow: hidden;
    }
    #hint-text {
      width: 360px;
      position: absolute;
      top: 45%;
      left: 50%;
      margin: -160px -180px;
      padding: 160px 0;
      border-radius: 50%;
      background-color:rgba(220,220,220,0.2);/*var(--light-divider-color);*/
      color: rgba(200,200,200,1);/*var(--light-divider-color);*/
      text-align: center;
      font-size: 22px;
      font-weight: bold;
    }
    #confirmation {
      padding: 12px;
      height: 80px;
      width: 200px;
      color: #D23216;/*var(--sec-accent-color);*/
    }
    #confirmation paper-button {
      font-size: 13px;
      position: absolute;
      margin: 0;
      left: 0;
      bottom:0;
      width: 100%;
    }
    #hypers, #conns {
      position: absolute;
      top: 100px;
      bottom: 35px;
    }
  </style>
  <template>
    <paper-input id="subjectName"
      name="name"
      label="Nome do Curso"
      on-change="_updateSubject">
    </paper-input>
    <div id="backcanvas">
      <canvas id="canvas"></canvas>
    </div>
    <div id="toucharea"
      on-tap="composerTap">
      <template is="dom-if" if="{{empty}}">
        <div id="hint-text">Clique para adicionar um hypervideo</div>
      </template>
    </div>
    <paper-dialog id="confirmation"
    entry-animation="scale-up-animation"
    exit-animation="scale-down-animation"
    on-iron-overlay-closed="onDismiss"
    with-backdrop>
      Deseja excluir o hypervideo?
      <paper-button id="confirmButton"
      on-tap="confirmDelete"
      dialog-confirm>SIM!</paper-button>
    </paper-dialog>
    <div id="nodes">
      <grid-container id="hypers">
        <!-- this is where hypervideo-nodes will be displayed -->
      </grid-container>
      <div id="conns">
        <!-- this is where connection-nodes will be displayed -->
      </div>
    </div>
  </template>
  <script>
    Polymer({
//======================== Polymer Component Methods =========================//
      is: 'subject-composer-area',
      properties: {
        // when connecting hypervideos, this property
        // catches the ids for creating connections
        connectId: {
          type: String,
          value: null,
          notify: true,
          observer: "connectIdChanged"
        },
        // if any hypervideo is being dragged, this
        // property handles the redraw of connections
        dragging: {
          type: Boolean,
          value: false,
          notify: true,
          observer: "draggingChanged"
        },
        // if any hypervideo is being deleted, this
        // property handles the confirmation request
        deleting: {
          type: Boolean,
          value: false,
          notify: true,
          observer: "deletingChanged"
        },
        // property that holds the model element: a Subject
        subject: {
          type: Object,
          value: null,
        },
        hypervideos: {
          type: Object,
          value: null,
        },
        empty: {
          type: Boolean,
          value: true,
        }
      },
      listeners: {
        'iron-resize': '_onIronResize'
      },
      behaviors: [
        Polymer.IronResizableBehavior
      ],
//========================= Custom Component Methods =========================//
      composerTap: function(e) {
        this.$.hypers.bounds = this._getTouchableBounds();
        this._updateSubject(e);
        this._createHypervideo(e);
        this.emptyComposer();
      },
      connectIdChanged: function (newConnectId) {
        var list = this.$.nodes.querySelectorAll(
          'hypervideo-node, connection-node');
        var length = list.length;
        for(var i=0; i<length; i++) {
          var element = list[i];
          element.connectId = newConnectId;
        }
      },
      draggingChanged: function (newDragging) {
        var self = this;
        self._drawInterval = setInterval(function() {
          self._drawConnections();
        }, 1);
        if(!self.dragging) {
          clearInterval(self._drawInterval);
        }
      },
      deletingChanged: function (newDeleting) {
        var self = this;
        if(self.deleting) {
          self.$.confirmation.open();
        }
      },
      confirmDelete: function() {
        var self = this;
        if(self._deletingNode){
          self.$.hypers.removeGridChild(self._deletingNode);
          self._deletingNode = null;
          self._drawConnections();
        }
        self.emptyComposer();
      },
      onDismiss: function() {
        var self = this;
        if(self._deletingNode){
          self._deletingNode.deleting = false;
          self._deletingNode = null;
        }
        self.deleting = false;
      },
      emptyComposer: function() {
        var nodes = this.$.hypers.querySelectorAll('hypervideo-node');
        this.empty = (nodes.length < 1);
      },
//===================== Custom Component Private Methods =====================//
      _createHypervideo: function(e) {
        var self = this;
        // defines bounds and offset of dragging limits for a hypervideoNode
        var bounds = self.$.hypers.bounds;

        var touchX = e.detail.x - bounds.x;
        var touchY = e.detail.y - bounds.y;
        var options = {
          x : touchX,
          y : touchY,
          bounds: bounds,
          subjectId: self.subject._id,
          connectId: self.connectId
        }
        var hypervideoNode = new HypervideoNode(options);
        self._addHypervideoListeners(hypervideoNode);
        self.$.hypers.appendGridChild(hypervideoNode);
      },
      _updateSubject: function() {
        if(this.subject === null) {
          this.fire('subject-created');
        }
        if(this.subject) {
          if(this.$.subjectName.value === "") {
            this.$.subjectName.value = this.subject.name;
          } else if (this.$.subjectName.value !== this.subject.name) {
            this.subject.name = this.$.subjectName.value;
            this.fire('subject-changed');
          }
        }
      },
      _connect: function(firstId, secondId) {
        var self = this;
        if(firstId !== secondId) {
          this._connection = {first: firstId, second: secondId};
          this.fire('connection-created');
          if(this._connection){
            var connNode = new ConnectionNode(this._connection);
            connNode.addEventListener('detached', function(ev){
              self._connectionListener(this);
            });
            self.$.conns.appendChild(connNode);
            self._resetConnecting();
          }
          self._resetConnecting();
        }
        self._drawConnections();
      },
      _drawConnections: function() {
        var self = this;
        var canvasScale = 3;
        var lineWidth = 4;
        var connections = self.$.conns.querySelectorAll('connection-node');
        var canvas = self.$.canvas;
        canvas.width  = canvasScale * canvas.offsetWidth;
        canvas.height = canvasScale * canvas.offsetHeight;
        var ctx = canvas.getContext("2d");
        ctx.beginPath();
        for(var i=0; i< connections.length; i++) {
          var conn = connections[i].connection;
          //FIX ME find a better way to do it...
          var first = self._findHypervideoNode(conn.first);
          var second = self._findHypervideoNode(conn.second);
          if(first && second) {
            var firstPos = first.getPos();
            var secondPos = second.getPos();
            var x1 = canvasScale * (firstPos.x);
            var y1 = canvasScale * (firstPos.y);
            var x2 = canvasScale * (secondPos.x);
            var y2 = canvasScale * (secondPos.y);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            self._showConnection(conn, firstPos, secondPos);
          }
        }
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      },
      //hypervideo listener functions
      _connectListener: function(hnInstance) {
        var self = this;
        self.connectId = hnInstance.connectId;

        if(self.connectId) {
          if(!self._firstId) {
            self._firstId = self.connectId;
          } else {
            self._connect(self._firstId, self.connectId);
          }
        } else {
          self._firstId = self.connectId;
        }
      },
      _deletingListener: function(hnInstance) {
        var self = this;
        self.deleting = hnInstance.deleting;
        self._deletingNode = hnInstance;
      },
      _draggingListener: function(hnInstance) {
        var self = this;
        self.dragging = hnInstance.dragging;
      },
      _findHypervideoNode: function(id) {
        var self = this;
        return self.$.hypers.querySelector('#_'+id);
      },
      _resetConnecting: function(){
        var self = this;
        self.connectId = null;
        self._firstId = null;
      },
      _addHypervideoListeners: function(hypervideoNode) {
        var self = this;
        hypervideoNode.addEventListener('connect-id-changed', function(ev){
          self._connectListener(this);
        });
        hypervideoNode.addEventListener('deleting-changed', function(ev){
          self._deletingListener(this);
        });
        hypervideoNode.addEventListener('dragging-changed', function(ev){
          self._draggingListener(this);
        });
      },
      //connection Listener functions
      _connectionListener: function(connInstance) {
        var self = this;
        this._connection = connInstance.connection;
        this.fire('connection-removed');
        self._drawConnections();
      },
      _showConnection: function(connection, firstPos, secondPos) {
        var self = this;
        var xmid = (firstPos.x + secondPos.x)/2;
        var ymid = (firstPos.y + secondPos.y)/2;
        var list = self.$.conns.querySelectorAll('connection-node');
        for(var i=0; i<list.length; i++) {
          var connNode = list[i];
          if(connNode.connection === connection) {
              connNode.setPos(xmid, ymid);
              return;
          }
        }
      },
      _getTouchableBounds: function() {
        var self = this;
        var rect = self.$.toucharea.getBoundingClientRect();
        var bounds = {
          width: rect.right - rect.left,
          height: rect.bottom - rect.top,
          x: rect.left,
          y: rect.top
        }
        return bounds;
      },
      _onIronResize: function() {
        this.$.hypers.bounds = this._getTouchableBounds();
      },
    });
  </script>
</dom-module>
