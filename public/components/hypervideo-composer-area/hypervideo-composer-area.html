<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-drawer-panel/paper-drawer-panel.html">
<link rel="import" href="../../components/subvideo-composer/subvideo-composer.html">
<link rel="import" href="../../components/subvideo-node/subvideo-node.html">
<link rel="import" href="../../components/connection-node/connection-node.html">

<dom-module id="hypervideo-composer-area">
  <style is="custom-style">
  #backcanvas {
    position: absolute;
    top: 75px;
    bottom: 10px;
    left: 10px;
    right: 10px;
  }
  #backcanvas canvas{
    width: 100%;
    height: 100%;
    background-color:rgba(246,246,246,1);/*var(--light-divider-color);*/
  }
  .options {
    position: relative;
    width: 100%;
  }
  #hypervideoName {
    width: 70%;
    margin: 0 10px;
    float: left;
  }
  #toggleDrawer,
  #closeButton {
    float: right;
    max-width: 30px;
    width: 20%;
    font-size: 12px;
  }
  .box {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  .box .row.content {
    flex: 1 .01 auto;
    overflow: scroll;
  }
  .box .row.footer {
    flex: 0 1 auto;
    min-height: 80px;
    overflow: hidden;
  }
  #fileInputArea {
    color: transparent;
    position: relative;
    width: 100%;
    height: 100%;
    background-color:rgba(220,220,220,0);/*var(--light-divider-color);*/
    overflow: hidden;
  }
  #inputfile{
    opacity: 0;
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 2;
  }
  #hint-text {
    position: absolute;
    left: 10px;
    top: 10px;
    right: 10px;
    bottom: 10px;
    background-color:rgba(220,220,220,0.2);/*var(--light-divider-color);*/
    color: rgba(200,200,200,1);/*var(--light-divider-color);*/
    text-align: center;
    font-size: 20px;
    font-weight: bold;
    z-index: 0;
  }
  #hint-text span {
    position: absolute;
    width: 200px;
    left: 50%;
    top: 50%;
    margin:-20px 0 0 -100px;
  }
  </style>
  <template>
    <paper-drawer-panel id=drawer>
      <div drawer>
        <div class="box">
          <div class="row content">
            <!-- Here will be displayed uploaded videos -->
            <template id="files" is="dom-repeat" items="{{fileObjects}}" as="videoFile">
              <subvideo-composer file="{{videoFile}}" on-upload-complete="handleUploadComplete"></subvideo-composer>
            </template>
          </div>
          <div id="fileInputArea"
            class="row footer"
            on-tap="composerTap">
            <input id="inputfile"
              type="file" multiple
              accept="video/*"
              on-change="loadFiles">
            </input>
            <div id="hint-text">
              <span>
                Clique para fazer upload de v√≠deos
              </span>
            </div>
          </div>
        </div>
      </div>
      <div main>
        <div class="options">
          <paper-button id="closeButton"
          dialog-confirm autofocus>Fechar</paper-button>
          <paper-input id="hypervideoName"
            name="name"
            label="Nome do Hypervideo"
            value="{{hypervideo.name}}"
            on-change="_updateHypervideo">
          </paper-input>
          <paper-button id="toggleDrawer"
          on-tap="toggleDrawer">videos</paper-button>
        </div>
        <div id="backcanvas">
          <canvas id="canvas"></canvas>
        </div>
        <div id="subvideosFrame">
        <!-- this is where subvideos will be displayed -->
      </div>
      </div>
    </paper-drawer-panel>
  </template>
  <script>
    Polymer({
//============================= Polymer Methods ==============================//
      is: 'hypervideo-composer-area',
      properties: {
        fileObjects: {
          type: Array,
          value: function() {
              return [];
          }
        },
        filesProgress: {
          type: Array,
        },
        // property that holds the model element: a Hypervideo
        hypervideo: {
          type: Object,
          value: null,
        },
        // if any hypervideo is being dragged, this
        // property handles the redraw of connections
        dragging: {
          type: Boolean,
          value: false,
          notify: true,
          observer: "draggingChanged"
        },
        connectId: {
          type: String,
          value: null,
          notify: true,
          observer: "connectIdChanged"
        },
      },
      ready: function() {
        this.firstTouch = true;
        this.$.drawer.forceNarrow = true;
        this.$.drawer.openDrawer();
      },
//============================= Public Methods ===============================//
      handleUploadComplete: function(e) {
        var self = this;
        self._createSubvideo(e.target);
      },
      composerTap: function(e) {
      },
      toggleDrawer: function() {
        this.$.drawer.togglePanel();
      },
      loadFiles: function(e) {
        this.files = e.target.files;
        this.fire('upload-videos');
      },
      connectIdChanged: function (newConnectId) {
        var list = this.querySelectorAll('subvideo-node, connection-node');
        var length = list.length;
        for(var i=0; i<length; i++) {
          var element = list[i];
          element.connectId = newConnectId;
        }
      },
      draggingChanged: function (newDragging) {
        var self = this;
        if(self.dragging) {
          self._drawInterval = setInterval(function() {
            self._drawConnections();
          }, 40);
        } else {
          clearInterval(self._drawInterval);
        }
      },
//============================= Private Methods ==============================//
      _createSubvideo: function(subvideoComposer) {
        var self = this;
        var xOffset = 35; // depends on initial definition in toucharea css
        var yOffset = 100;// depends on initial definition in toucharea css
        // defines bounds and offset of dragging limits for a hypervideoNode
        var rect = self.$.backcanvas.getBoundingClientRect();
        var bounds = {
          width: rect.right - rect.left,
          height: rect.bottom - rect.top,
          x: rect.left-xOffset,
          y: rect.top-yOffset
        };

        var pos = self._nextNodePos();
        var options = {
          x : pos.x,
          y : pos.y,
          bounds: bounds,
          mediaId: subvideoComposer.file._id,
          name: subvideoComposer.file.data.blob.name,
          connectId: self.connectId
        }
        var subvideoNode = new SubvideoNode(options);
        self._addSubvideoListeners(subvideoNode);
        self.$.subvideosFrame.appendChild(subvideoNode);
        subvideoComposer.subvideo = subvideoNode.subvideo;
      },
      _updateHypervideo: function() {
        this.fire('hypervideo-changed');
      },
      _nodesCount: function() {
        var self = this;
        var list = self.querySelectorAll('subvideo-node');
        return list.length;
      },
      _nextNodePos: function() {
        var self = this;
        var i = self._nodesCount();
        var pos = {
          x: 300 + i * 70,
          y: 110 + i * 20
        };
        return pos;
      },
      _connect: function(firstId, secondId) {
        var self = this;
        if(firstId !== secondId) {
          var connection = {first: firstId, second: secondId};
          if(self.hypervideo.addConnection(connection)){
            var connNode = new ConnectionNode(connection);
            connNode.addEventListener('connection-removed', function(ev){
              self._connectionListener(this);
            });
            self.$.subvideosFrame.appendChild(connNode);
            self._resetConnecting();
            self.fire('hypervideo-changed');
          }
          self._resetConnecting();
        }
        self._drawConnections();
      },
      _drawConnections: function() {
        var self = this;
        var canvasScale = 3;
        var lineWidth = 4;
        var connections = self.querySelectorAll('connection-node');
        var canvas = self.$.canvas;
        canvas.width  = canvasScale * canvas.offsetWidth;
        canvas.height = canvasScale * canvas.offsetHeight;
        var canvasXOffset = 10;
        var canvasYOffset = 75;
        var ctx = canvas.getContext("2d");

        ctx.beginPath();
        for(var i=0; i< connections.length; i++) {
          var conn = connections[i].connection;
          //FIX ME find a better way to do it...
          var first = self._findSubvideoNode(conn.first);
          var second = self._findSubvideoNode(conn.second);
          if(first && second) {
            var firstPos = first.getPos();
            var secondPos = second.getPos();
            var x1 = canvasScale * (firstPos.x - canvasXOffset);
            var y1 = canvasScale * (firstPos.y - canvasYOffset);
            var x2 = canvasScale * (secondPos.x - canvasXOffset);
            var y2 = canvasScale * (secondPos.y - canvasYOffset);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            self._showConnection(conn, firstPos, secondPos);
          }
          else {
            self.removeChild(connections[i]);
          }
        }
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      },
      _findSubvideoNode: function(id) {
        var self = this;
        return self.querySelector('#_'+id);
      },
      _resetConnecting: function(){
        var self = this;
        self.connectId = null;
        self._firstId = null;
      },
      //subvideo listener functions
      _connectListener: function(snInstance) {
        var self = this;
        self.connectId = snInstance.connectId;
        if(self.connectId) {
          if(!self._firstId) {
            self._firstId = self.connectId;
          } else {
            self._connect(self._firstId, self.connectId);
          }
        } else {
          self._firstId = self.connectId;
        }
      },
      _draggingListener: function(snInstance) {
        var self = this;
        self.dragging = snInstance.dragging;
      },
      _addSubvideoListeners: function(subvideoNode) {
        var self = this;
        subvideoNode.addEventListener('connect-id-changed', function(ev){
          self._connectListener(this);
        });
        subvideoNode.addEventListener('dragging-changed', function(ev){
          self._draggingListener(this);
        });
      },
      //connection Listener functions
      _connectionListener: function(connInstance) {
        var self = this;
        self.$.subvideosFrame.removeChild(connInstance);
        self._drawConnections();
      },
      _showConnection: function(connection, firstPos, secondPos) {
        var self = this;
        var xmid = (firstPos.x + secondPos.x)/2;
        var ymid = (firstPos.y + secondPos.y)/2;
        var list = self.querySelectorAll('connection-node');
        for(var i=0; i<list.length; i++) {
          var connNode = list[i];
          if(connNode.connection === connection) {
              connNode.setPos(xmid, ymid);
              return;
          }
        }
      }
    });
  </script>
</dom-module>
